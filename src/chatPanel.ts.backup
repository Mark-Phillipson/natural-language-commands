import * as vscode from 'vscode';
// Utility to log to VS Code Output channel
function logToOutputChannel(message: string) {
	const channel = vscode.window.createOutputChannel('NLC Debug');
	channel.appendLine(message);
	channel.show(true);
}
import { getLLMResult, LLMResult } from './llm';

interface ChatMessage {
	role: 'user' | 'assistant' | 'system';
	content: string;
	timestamp: Date;
	commandResult?: LLMResult;
}

interface FeedbackData {
	userInput: string;
	llmResult: LLMResult;
	wasCorrect: boolean;
	userFeedback?: string;
	timestamp: Date;
}

export class ChatPanel {
	public static currentPanel: ChatPanel | undefined;
	private readonly _panel: vscode.WebviewPanel;
	private readonly _extensionUri: vscode.Uri;
	private _disposables: vscode.Disposable[] = [];
	private _conversationHistory: ChatMessage[] = [];
	private _feedbackHistory: FeedbackData[] = [];
	private _context: vscode.ExtensionContext;
	public initialMessage?: string;

	public static createOrShow(extensionUri: vscode.Uri, context: vscode.ExtensionContext, initialMessage?: string) {
		const column = vscode.window.activeTextEditor
			? vscode.window.activeTextEditor.viewColumn
			: undefined;

		// If we already have a panel, show it
		if (ChatPanel.currentPanel) {
			ChatPanel.currentPanel._panel.reveal(column);
			// If a new initialMessage is provided, update it and send to webview
			if (initialMessage) {
				ChatPanel.currentPanel.initialMessage = initialMessage;
				ChatPanel.currentPanel._handleInitialMessage(initialMessage);
			}
			return ChatPanel.currentPanel;
		}

		// Otherwise, create a new panel
		const panel = vscode.window.createWebviewPanel(
			'nlcChat',
			'Natural Language Commands Chat',
			column || vscode.ViewColumn.One,
			{
				enableScripts: true,
				retainContextWhenHidden: true,
				localResourceRoots: [extensionUri]
			}
		);

		ChatPanel.currentPanel = new ChatPanel(panel, extensionUri, context, initialMessage);
		return ChatPanel.currentPanel;
	}

	private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri, context: vscode.ExtensionContext, initialMessage?: string) {
		this._panel = panel;
		this._extensionUri = extensionUri;
		this._context = context;
		if (initialMessage) {
			this.initialMessage = initialMessage;
			this._handleInitialMessage(initialMessage);
		}

		// Load existing feedback history from storage
		this._feedbackHistory = context.globalState.get<FeedbackData[]>('nlc.feedbackHistory', []);

		// Set the webview's initial html content
		this._update();

		// Listen for when the panel is disposed
		this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

		// Handle messages from the webview
		this._panel.webview.onDidReceiveMessage(
			async message => {
				console.log('[ChatPanel] Received message from webview:', message);
				if (message.type === 'ready') {
					// Webview is ready, replay conversation history
					for (const msg of this._conversationHistory) {
						this._panel.webview.postMessage({
							type: 'addMessage',
							payload: {
								role: msg.role,
								content: msg.content,
								commandResult: msg.commandResult,
								showActions: msg.role === 'assistant' && !!msg.commandResult
							}
						});
					}
					return;
				}
				switch (message.type) {
					case 'userMessage':
						await this._handleUserMessage(message.text);
						break;
					case 'executeCommand':
						await this._executeCommand(message.command, message.terminal);
						break;
					case 'provideFeedback':
						await this._storeFeedback(message.feedback);
						break;
					case 'refineCommand':
						await this._refineCommand(message.refinement);
						break;
				}
			},
			null,
			this._disposables
		);
	}

	private _handleInitialMessage(message: string) {
		// Add the initial message to the conversation and update the UI
		this._conversationHistory.push({
			role: 'user',
			content: message,
			timestamp: new Date()
		});
		this._sendMessageToWebview('addMessage', { role: 'user', content: message });
	}

	private async _handleUserMessage(text: string) {
		// Add user message to conversation
		this._conversationHistory.push({
			role: 'user',
			content: text,
			timestamp: new Date()
		});

		// Update UI to show user message
		this._sendMessageToWebview('addMessage', { role: 'user', content: text });

		// Show "thinking" indicator with API key prefix
		const apiKey = process.env.OPENAI_API_KEY;
		let apiKeyPrefix = 'none';
		if (apiKey && typeof apiKey === 'string') {
			apiKeyPrefix = apiKey.substring(0, 5);
		}
		this._sendMessageToWebview('setThinking', { thinking: `true|${apiKeyPrefix}` });
		const stepMsg = `[STEP 1] Handling user message. API Key prefix: ${apiKeyPrefix}`;
		console.log(stepMsg);
		logToOutputChannel(stepMsg);
		this._sendMessageToWebview('addMessage', { role: 'system', content: stepMsg });

		let step2shown = false;
		let fallbackTimeout: NodeJS.Timeout | undefined = setTimeout(() => {
			this._sendMessageToWebview('addMessage', {
				role: 'system',
				content: '[FALLBACK] No response from LLM/API after 25 seconds. Please check your API key, network, or see Output panel.'
			});
			logToOutputChannel('[FALLBACK] No response from LLM/API after 25 seconds.');
		}, 25000);

		try {
			if (!apiKey) {
				this._sendMessageToWebview('setThinking', { thinking: false });
				const errMsg = '[STEP 2] Error: OpenAI API key not found. Please set OPENAI_API_KEY in your .env file.';
				this._sendMessageToWebview('addMessage', {
					role: 'system',
					content: errMsg
				});
				console.error('[ChatPanel] No API key found.');
				logToOutputChannel(errMsg);
				if (fallbackTimeout) { clearTimeout(fallbackTimeout); }
				return;
			}

			const config = vscode.workspace.getConfiguration();
			const model = config.get<string>('naturalLanguageCommands.model', 'gpt-4o');
			const step2 = `[STEP 2] Calling getLLMResult with model: ${model}`;
			console.log(step2);
			logToOutputChannel(step2);
			this._sendMessageToWebview('addMessage', { role: 'system', content: step2 });
			step2shown = true;

			// Add a timeout for the LLM call (e.g., 20 seconds)
			const llmPromise = getLLMResult(apiKey, text, model);
			const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('LLM/API call timed out after 20 seconds')), 20000));
			let result: LLMResult | undefined = undefined;
			try {
				result = await Promise.race([llmPromise, timeoutPromise]) as LLMResult;
			} catch (llmError: unknown) {
				if (fallbackTimeout) { clearTimeout(fallbackTimeout); }
				const errMsg = '[STEP 3] LLM/API call failed or timed out: ' + (llmError && typeof llmError === 'object' && 'message' in llmError && typeof (llmError as any).message === 'string' ? (llmError as any).message : (typeof llmError === 'string' ? llmError : JSON.stringify(llmError)));
				console.error(errMsg);
				logToOutputChannel(errMsg);
				this._sendMessageToWebview('setThinking', { thinking: false });
				this._sendMessageToWebview('addMessage', {
					role: 'system',
					content: errMsg
				});
				return;
			}
			if (fallbackTimeout) { clearTimeout(fallbackTimeout); }
			const step3 = '[STEP 3] LLM result: ' + JSON.stringify(result);
			console.log(step3);
			logToOutputChannel(step3);
			this._sendMessageToWebview('addMessage', { role: 'system', content: step3 });

			if (!result) {
				this._sendMessageToWebview('setThinking', { thinking: false });
				const warnMsg = '[STEP 4] No response received from the LLM/API. Please try again or check your API key and network.';
				this._sendMessageToWebview('addMessage', {
					role: 'system',
					content: warnMsg
				});
				console.warn(warnMsg);
				logToOutputChannel(warnMsg);
				if (fallbackTimeout) { clearTimeout(fallbackTimeout); }
				return;
			}

			// Add assistant response to conversation
			const assistantMessage: ChatMessage = {
				role: 'assistant',
				content: this._formatLLMResponse(result),
				timestamp: new Date(),
				commandResult: result
			};
			this._conversationHistory.push(assistantMessage);

			// Update UI
			this._sendMessageToWebview('setThinking', { thinking: false });
			// Debug: show assistant payload as system message
			const assistantPayload = {
				role: 'assistant',
				content: assistantMessage.content,
				commandResult: result,
				showActions: true
			};
			this._sendMessageToWebview('addMessage', {
				role: 'system',
				content: '[DEBUG] Assistant payload: ' + JSON.stringify(assistantPayload)
			});
			this._sendMessageToWebview('addMessage', assistantPayload);
			const step4 = '[STEP 5] Assistant message sent to webview.';
			console.log(step4);
			logToOutputChannel(step4);
			this._sendMessageToWebview('addMessage', { role: 'system', content: step4 });
			// Automatically execute the command if present, otherwise ask for clarification
			if (result.command || result.terminal) {
				await this._executeCommand(result.command ?? null, result.terminal ?? null);
			} else {
				const clarificationMsg = "Sorry, I couldn't understand your request. Please clarify or rephrase your command.";
				this._sendMessageToWebview('addMessage', { role: 'system', content: clarificationMsg });
				logToOutputChannel('[STEP 6] ' + clarificationMsg);
			}
			if (fallbackTimeout) { clearTimeout(fallbackTimeout); }

		} catch (error: any) {
			this._sendMessageToWebview('setThinking', { thinking: false });
			let errorMsg = '[STEP 6] Unknown error';
			if (error && error.message) {
				errorMsg = '[STEP 6] ' + error.message;
			} else if (typeof error === 'string') {
				errorMsg = '[STEP 6] ' + error;
			} else if (error && error.response && error.response.data) {
				errorMsg = '[STEP 6] ' + JSON.stringify(error.response.data);
			}
			this._sendMessageToWebview('addMessage', {
				role: 'system',
				content: `Error from LLM/API: ${errorMsg}`
			});
			console.error('[ChatPanel] Error in _handleUserMessage:', error);
			logToOutputChannel('[ChatPanel] Error in _handleUserMessage: ' + errorMsg);
			if (fallbackTimeout) { clearTimeout(fallbackTimeout); }
		}
	}

	private _formatLLMResponse(result: LLMResult): string {
		let response = `**Intent**: ${result.intent}\n\n`;

		if (result.command) {
			response += `**VS Code Command**: \`${result.command}\`\n\n`;
		}

		if (result.terminal) {
			response += `**Terminal Command**: \`${result.terminal}\`\n\n`;
		}

		if (result.search) {
			response += `**Search Term**: \`${result.search}\`\n\n`;
		}

		response += `**Confidence**: ${(result.confidence * 100).toFixed(0)}%\n\n`;

		if (result.alternatives && result.alternatives.length > 0) {
			response += `**Alternatives**:\n`;
			result.alternatives.forEach((alt, idx) => {
				response += `${idx + 1}. `;
				if (alt.command) {
					response += `Command: \`${alt.command}\` `;
				}
				if (alt.terminal) {
					response += `Terminal: \`${alt.terminal}\` `;
				}
				if (alt.description) {
					response += `— ${alt.description}`;
				}
				response += '\n';
			});
		}

		return response;
	}

	private async _executeCommand(command: string | null, terminal: string | null) {
		try {
			// Get the last command result to check confidence
			const lastAssistantMsg = [...this._conversationHistory]
				.reverse()
				.find(msg => msg.role === 'assistant' && msg.commandResult);

			const confidence = lastAssistantMsg?.commandResult?.confidence || 0;
			const CONFIDENCE_THRESHOLD = 0.9;

			// Check confidence threshold
			if (confidence < CONFIDENCE_THRESHOLD) {
				const shouldExecute = await vscode.window.showWarningMessage(
					`I'm ${Math.round(confidence * 100)}% confident about this command.\n\nDo you want to proceed?`,
					{ modal: true },
					'Execute Anyway',
					'Cancel'
				);

				if (shouldExecute !== 'Execute Anyway') {
					this._sendMessageToWebview('addMessage', {
						role: 'system',
						content: '❌ Command execution cancelled due to low confidence.'
					});
					return;
				}
			}

			if (command && command.trim().length > 0) {
				const trimmed = command.trim();
				await vscode.commands.executeCommand(trimmed);
				this._sendMessageToWebview('addMessage', {
					role: 'system',
					content: `✅ Successfully executed command (${Math.round(confidence * 100)}% confidence): \`${trimmed}\``
				});
			} else if (terminal && terminal.trim().length > 0) {
				let terminalInstance = vscode.window.activeTerminal;
				if (!terminalInstance) {
					terminalInstance = vscode.window.createTerminal('NLC Terminal');
				}
				terminalInstance.show();
				terminalInstance.sendText(terminal.trim(), true);
				this._sendMessageToWebview('addMessage', {
					role: 'system',
					content: `✅ Running in terminal (${Math.round(confidence * 100)}% confidence): \`${terminal}\``
				});
			}
		} catch (error: any) {
			this._sendMessageToWebview('addMessage', {
				role: 'system',
				content: `❌ Error executing command: ${error.message || error}`
			});
		}
	}

	private async _storeFeedback(feedback: { wasCorrect: boolean; userFeedback?: string }) {
		// Get the last assistant message with command result
		const lastAssistantMsg = [...this._conversationHistory]
			.reverse()
			.find(msg => msg.role === 'assistant' && msg.commandResult);

		if (lastAssistantMsg && lastAssistantMsg.commandResult) {
			const lastUserMsg = [...this._conversationHistory]
				.reverse()
				.find(msg => msg.role === 'user');

			const feedbackData: FeedbackData = {
				userInput: lastUserMsg?.content || '',
				llmResult: lastAssistantMsg.commandResult,
				wasCorrect: feedback.wasCorrect,
				userFeedback: feedback.userFeedback,
				timestamp: new Date()
			};

			this._feedbackHistory.push(feedbackData);

			// Store in global state (limit to last 100 feedback items)
			const limitedHistory = this._feedbackHistory.slice(-100);
			await this._context.globalState.update('nlc.feedbackHistory', limitedHistory);

			this._sendMessageToWebview('addMessage', {
				role: 'system',
				content: feedback.wasCorrect
					? '✅ Thanks for the positive feedback!'
					: '❌ Thanks for the feedback. This will help improve future suggestions.'
			});
		}
	}

	private async _refineCommand(refinement: string) {
		// Treat refinement as a follow-up message with context
		const contextMessage = `Previous command didn't work as expected. User refinement: ${refinement}`;
		await this._handleUserMessage(contextMessage);
	}

	private _sendMessageToWebview(type: string, payload: any) {
		// If this is a system/debug message, add to conversation history
		if (type === 'addMessage' && payload && payload.role === 'system') {
			this._conversationHistory.push({
				role: 'system',
				content: payload.content,
				timestamp: new Date()
			});
		}
		this._panel.webview.postMessage({ type, payload });
	}

	private _update() {
		const webview = this._panel.webview;
		this._panel.webview.html = this._getHtmlForWebview(webview);
        // Conversation history will be replayed after webview signals 'ready'.
	}

	private _getHtmlForWebview(webview: vscode.Webview): string {
		return `<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline'; script-src 'unsafe-inline';">
	<title>Natural Language Commands Chat</title>
	<style>
		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}
		body {
			font-family: var(--vscode-font-family);
			color: var(--vscode-foreground);
			background-color: var(--vscode-editor-background);
			display: flex;
			flex-direction: column;
			height: 100vh;
			overflow: hidden;
		}
		#chat-container {
			flex: 1;
			overflow-y: auto;
			padding: 16px;
			display: flex;
			flex-direction: column;
			gap: 12px;
		}
		   .message {
			   padding: 8px 12px;
			   border-radius: 6px;
			   margin: 0 0 8px 0;
			   font-size: 15px;
			   font-family: inherit;
			   max-width: 100%;
			   word-wrap: break-word;
			   border: 1px solid #333;
			   background: #222;
		   }
		   .message.user {
			   color: #fff;
			   background: #0057b7;
			   border-color: #0057b7;
			   font-weight: 600;
		   }
		   .message.assistant {
			   color: #fff;
			   background: #228B22;
			   border-color: #228B22;
			   font-weight: 600;
		   }
		   .message.system {
			   color: #fff;
			   background: #ff9800;
			   border-color: #ff9800;
			   font-style: italic;
			   font-weight: 400;
		   }
		.message-actions {
			margin-top: 8px;
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
		}
		.message-actions button {
			background-color: var(--vscode-button-background);
			color: var(--vscode-button-foreground);
			border: none;
			padding: 6px 12px;
			border-radius: 4px;
			cursor: pointer;
			font-size: 12px;
		}
		.message-actions button:hover {
			background-color: var(--vscode-button-hoverBackground);
		}
		.feedback-buttons {
			margin-top: 8px;
			display: flex;
			gap: 8px;
		}
		.feedback-buttons button {
			flex: 1;
			padding: 6px 12px;
			border: 1px solid var(--vscode-panel-border);
			background-color: var(--vscode-editor-background);
			color: var(--vscode-foreground);
			cursor: pointer;
			border-radius: 4px;
		}
		.feedback-buttons button:hover {
			background-color: var(--vscode-list-hoverBackground);
		}
		.feedback-buttons button.positive:hover {
			border-color: var(--vscode-testing-iconPassed);
		}
		.feedback-buttons button.negative:hover {
			border-color: var(--vscode-testing-iconFailed);
		}
		#input-container {
			padding: 16px;
			border-top: 1px solid var(--vscode-panel-border);
			display: flex;
			gap: 8px;
			background-color: var(--vscode-editor-background);
		}
		#user-input {
			flex: 1;
			padding: 8px 12px;
			background-color: var(--vscode-input-background);
			color: var(--vscode-input-foreground);
			border: 1px solid var(--vscode-input-border);
			border-radius: 4px;
			font-family: inherit;
			font-size: 14px;
		}
		#user-input:focus {
			outline: none;
			border-color: var(--vscode-focusBorder);
		}
		#send-button {
			padding: 8px 20px;
			background-color: var(--vscode-button-background);
			color: var(--vscode-button-foreground);
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-weight: 500;
		}
		#send-button:hover {
			background-color: var(--vscode-button-hoverBackground);
		}
		#send-button:disabled {
			opacity: 0.5;
			cursor: not-allowed;
		}
		.thinking {
			align-self: flex-start;
			padding: 12px;
			color: var(--vscode-descriptionForeground);
			font-style: italic;
		}
		code {
			background-color: var(--vscode-textCodeBlock-background);
			padding: 2px 4px;
			border-radius: 3px;
			font-family: var(--vscode-editor-font-family);
		}
		.welcome-message {
			padding: 20px;
			text-align: center;
			color: var(--vscode-descriptionForeground);
		}
		.welcome-message h2 {
			margin-bottom: 12px;
			color: var(--vscode-foreground);
		}
	</style>
</head>
<body>
	<div id="chat-container">
		<div class="welcome-message">
			<h2>Natural Language Commands Chat</h2>
			<p>Type a command in natural language to get started.</p>
			<p>You can refine commands, provide feedback, and have a conversation to get the right result.</p>
		</div>
	</div>
	<div id="input-container">
		<input type="text" id="user-input" placeholder="Type your command here (e.g., 'Open the terminal and run my tests')..." />
		<button id="send-button">Send</button>
	</div>

	<script>
	// IMMEDIATE TEST - runs before anything else
	alert('Script loaded! If you see this alert, the script is running.');
	
	document.addEventListener('DOMContentLoaded', function() {
		const vscode = acquireVsCodeApi();
		const chatContainer = document.getElementById('chat-container');
		const userInput = document.getElementById('user-input');
		const sendButton = document.getElementById('send-button');
		let currentThinking = null;

		// Create visible debug log at the top
		var debugLog = document.createElement('div');
		debugLog.id = 'debug-log';
		debugLog.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; background: black; color: lime; padding: 10px; font-size: 12px; max-height: 150px; overflow-y: auto; z-index: 10000; border-bottom: 2px solid lime;';
		document.body.insertBefore(debugLog, document.body.firstChild);
		
		function log(msg) {
			var line = document.createElement('div');
			line.textContent = new Date().toLocaleTimeString() + ': ' + msg;
			debugLog.appendChild(line);
			debugLog.scrollTop = debugLog.scrollHeight;
			console.log(msg);
		}

		log('[Init] DOMContentLoaded fired');
		log('[Init] chatContainer: ' + (chatContainer ? 'found' : 'NOT FOUND'));
		log('[Init] userInput: ' + (userInput ? 'found' : 'NOT FOUND'));
		log('[Init] sendButton: ' + (sendButton ? 'found' : 'NOT FOUND'));

		// Apply inline styles to ensure visibility
		chatContainer.style.cssText = 'flex: 1; overflow-y: auto; padding: 16px; background: #1e1e1e; margin-top: 150px;';
		
		var inputContainer = document.getElementById('input-container');
		if (inputContainer) {
			inputContainer.style.cssText = 'padding: 16px; border-top: 1px solid #444; display: flex; gap: 8px; background: #2d2d2d;';
		}
		if (userInput) {
			userInput.style.cssText = 'flex: 1; padding: 8px 12px; background: #3c3c3c; color: white; border: 1px solid #555; font-size: 14px;';
		}
		if (sendButton) {
			sendButton.style.cssText = 'padding: 8px 20px; background: #0e639c; color: white; border: none; cursor: pointer; font-size: 14px; font-weight: 500;';
		}

		// Handshake: notify extension that webview is ready
		log('[Handshake] Sending ready message');
		vscode.postMessage({ type: 'ready' });

		function addMessage(role, content, commandResult, showActions) {
			console.log('[addMessage] Called with role:', role, 'content length:', content.length);
			
			// Hide the welcome message if it exists
			const welcome = chatContainer.querySelector('.welcome-message');
			if (welcome) {
				welcome.style.display = 'none';
				console.log('[addMessage] Hid welcome message');
			}
			// Make commandResult and showActions optional for backward compatibility
			if (typeof commandResult === 'undefined') commandResult = null;
			if (typeof showActions === 'undefined') showActions = false;
			
			// Create message div with inline styles (since CSS classes aren't working)
			var messageDiv = document.createElement('div');
			messageDiv.style.cssText = 'padding: 12px; margin: 0 0 10px 0; border-radius: 6px; font-size: 15px; word-wrap: break-word; border: 2px solid white;';
			
			// Set color and background based on role
			let prefix = '';
			if (role === 'user') {
				prefix = 'User: ';
				messageDiv.style.background = '#0057b7';
				messageDiv.style.color = '#fff';
				messageDiv.style.fontWeight = '600';
				messageDiv.style.borderColor = '#4ea1ff';
			} else if (role === 'assistant') {
				prefix = 'Assistant: ';
				messageDiv.style.background = '#228B22';
				messageDiv.style.color = '#fff';
				messageDiv.style.fontWeight = '600';
				messageDiv.style.borderColor = '#7ed957';
			} else if (role === 'system') {
				prefix = 'System: ';
				messageDiv.style.background = '#ff9800';
				messageDiv.style.color = '#000';
				messageDiv.style.fontStyle = 'italic';
				messageDiv.style.borderColor = '#ffb347';
			}
			
			// Parse markdown-style formatting (bold, code, newlines)
			const formattedContent = content
				.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
				.replace(/\`([^\`]+)\`/g, '<code style="background: rgba(0,0,0,0.3); padding: 2px 4px;">$1</code>')
				.replace(/\\n/g, '<br>');
			messageDiv.innerHTML = '<span>' + prefix + '</span>' + formattedContent;
			chatContainer.appendChild(messageDiv);
			chatContainer.scrollTop = chatContainer.scrollHeight;
			console.log('[addMessage] Added message div to chatContainer, total children:', chatContainer.children.length);
		}

		function setThinking(thinking) {
			console.log('[setThinking] Called with:', thinking);
			let showThinking = false;
			let apiKeyPrefix = '';
			if (typeof thinking === 'string' && thinking.startsWith('true|')) {
				showThinking = true;
				apiKeyPrefix = thinking.split('|')[1] || '';
			} else if (thinking === true) {
				showThinking = true;
			}
			if (showThinking) {
				if (!currentThinking) {
					currentThinking = document.createElement('div');
					// Use inline styles instead of className
					currentThinking.style.cssText = 'padding: 12px; color: #aaa; font-style: italic; background: #2d2d2d; border: 1px dashed #555; margin: 10px 0;';
					var message = 'Thinking...';
					if (apiKeyPrefix) {
						message = 'Thinking... (API Key: ' + apiKeyPrefix + '...)';
					}
					currentThinking.textContent = message;
					chatContainer.appendChild(currentThinking);
					chatContainer.scrollTop = chatContainer.scrollHeight;
					console.log('[setThinking] Added thinking indicator');
				}
			} else {
				// Instead of removing, just update the text and hide it or change its appearance
				if (currentThinking) {
					console.log('[setThinking] Hiding thinking indicator (changing text to "Done")');
					currentThinking.textContent = '✓ Done processing';
					currentThinking.style.color = '#4CAF50';
					currentThinking.style.background = '#1e3a1e';
					currentThinking.style.borderColor = '#4CAF50';
					// Or hide it completely:
					// currentThinking.style.display = 'none';
					chatContainer.scrollTop = chatContainer.scrollHeight;
				}
			}
		}
		}

		function sendMessage() {
			log('[sendMessage] Called');
			const text = userInput.value.trim();
			log('[sendMessage] Text length: ' + text.length);
			if (!text) {
				log('[sendMessage] Text is empty, returning');
				return;
			}
			log('[sendMessage] Posting message to extension');
			vscode.postMessage({
				type: 'userMessage',
				text: text
			});
			userInput.value = '';
			sendButton.disabled = true;
			log('[sendMessage] Message sent, input cleared, button disabled');
		}

		log('[Event Setup] Attaching event listeners...');
		
		if (sendButton) {
			sendButton.addEventListener('click', function(e) {
				log('[Click Event] Send button clicked');
				sendMessage();
			});
			log('[Event Setup] Click listener attached to sendButton');
		} else {
			log('[Event Setup] ERROR: sendButton not found!');
		}
		
		if (userInput) {
			userInput.addEventListener('keypress', function(e) {
				log('[Keypress Event] Key pressed: ' + e.key);
				if (e.key === 'Enter') {
					log('[Keypress Event] Enter key detected, calling sendMessage');
					sendMessage();
				}
			});
			log('[Event Setup] Keypress listener attached to userInput');
		} else {
			log('[Event Setup] ERROR: userInput not found!');
		}

		// Handle messages from the extension

	window.addEventListener('message', event => {
		const message = event.data;
		log('[Message] Received: ' + message.type);
		switch (message.type) {
			case 'addMessage':
				addMessage(
					message.payload.role,
					message.payload.content,
					message.payload.commandResult,
					message.payload.showActions
				);
				sendButton.disabled = false;
				break;
			case 'setThinking':
				setThinking(message.payload.thinking);
				break;
		}
	});

		// Focus input on load
		log('[Focus] Attempting to focus userInput');
		if (userInput) {
			userInput.focus();
			log('[Focus] userInput.focus() called');
			// Also try with a delay in case there's a timing issue
			setTimeout(function() {
				userInput.focus();
				log('[Focus] userInput.focus() called again after 100ms');
			}, 100);
		} else {
			log('[Focus] ERROR: Cannot focus, userInput is null!');
		}
		
		log('[Init] Setup complete!');
	});
	</script>
</body>
</html>`;
	}

	public dispose() {
		ChatPanel.currentPanel = undefined;

		this._panel.dispose();

		while (this._disposables.length) {
			const x = this._disposables.pop();
			if (x) {
				x.dispose();
			}
		}
	}
}
